(* Name: Quang Phung
 * Course: CSCI 2041
 * Lab 09-10
 * Due Date: 11/10/17 *)

(* Solution to Problem 1 *)
(* P1_1. *)
type state = int * int * int * int * int

(* P1_2. *)
let getI (i,n,temp,fib1,fib2) = i
let getN (i,n,temp,fib1,fib2) = n
let getTemp (i,n,temp,fib1,fib2) = temp
let getFib1 (i,n,temp,fib1,fib2) = fib1
let getFib2 (i,n,temp,fib1,fib2) = fib2

let putI exp s =
   let (i,n,temp,fib1,fib2) = s in (exp s,n,temp,fib1,fib2)
let putN exp s =
   let (i,n,temp,fib1,fib2) = s in (i,exp s,temp,fib1,fib2)
let putTemp exp s =
   let (i,n,temp,fib1,fib2) = s in (i,n,exp s,fib1,fib2)
let putFib1 exp s =
   let (i,n,temp,fib1,fib2) = s in (i,n,temp,exp s,fib2)
let putFib2 exp s =
   let (i,n,temp,fib1,fib2) = s in (i,n,temp,fib1,exp s)

(* P1_3. *)
let seq stat1 stat2 =
        fun s -> (stat2 (stat1 s))

let ifstat exp stat1 stat2 =
    fun s -> if (exp s) then (stat1 s)
             else (stat2 s)

let rec whilestat exp stat =
   fun s ->
      ifstat exp
             (seq stat (whilestat exp stat))
             (fun x -> x) s

let one = fun s -> 1
let i_not_equal_n = (fun s -> (getI s) <> (getN s))
let i_plus_one = (fun s -> (getI s) + 1)
let fib2_plus_temp = (fun s -> (getFib2 s) + (getTemp s))

let fibprog =
   seq (putI one)
       (seq (putFib1 one)
            (seq (putFib2 one)
	        (whilestat (i_not_equal_n)
		    (seq (putTemp getFib1)
		         (seq (putFib1 getFib2)
			      (seq (putFib2 fib2_plus_temp)
			           (putI i_plus_one)))))))

(* P1_4. *)
let fib7 = fibprog (0,7,0,0,0)
let fib x =
   let (i,n,temp,fib1,fib2) = fibprog (0,x,0,0,0)
      in fib1


(* Solution to Problem 2 *)
(* P2.1_1.
 * Property: (sumup n) evaluates to (1 + 2 + 3 + ... + n)
 *
 * P2.1_2.
 * Base: P(0) holds => (sumup 0) evaluates to 0 (true)
 * Inductive steps:
 *   - Assume that P(n) holds => (sumup n) evaluates to (1 + 2 + 3 + ... + n)
 *   - Show that P(n+1) holds => (sumup (n+1)) evaluates to (1 + 2 + 3 + ... + n + n+1)
 *     (sumup (n+1)) evaluates to (n+1 + (sumup n)) which evaluates to
 *     (n+1 + (1 + 2 + 3 + ... + n)) by the assumption
 *     = (1 + 2 + 3 + ... + n + n+1)
 *  => P(n+1) holds true
 *  => (sumup n) evaluates to (1 + 2 + 3 + ... + n)
 *)

(* P2.2_1.
 * Property: (sumup_aux n acc) evaluates to (1 + 2 + 3 + ... + n + acc)
 *
 * P2.2_2.
 * Base: P(0) holds => (sumup 0 acc) evaluates to acc which is equal to (0 + acc) (true)
 * Inductive steps:
 *   - Assum that P(n) holds => (sumup_aux n acc) evaluates to (1 + 2 + 3 + ... + n + acc)
 *   - Show that P(n+1) holds => (sumup_aux (n+1) acc) evaluates to (1 + 2 + 3 + ... + n + n+1 + acc)
 *     (sumup_aux (n+1) acc) evaluates to (sumup_aux n (n+1 + acc)
 *     which in turn evaluates to (1 + 2 + 3 + ... + n + n+1 + acc) by the assumption
 *  => P(n+1) holds true
 *
 * P2.2_3.
 * (sumup' n) evaluates to whatever (sumup_aux n 0) evaluates to
 * (sumup_aux n 0) evaluates to (1 + 2 + 3 + ... + n + 0)
 *   => (sumup' n) evaluates to (1 + 2 + 3 + ... + n)
 *)


(* Solution to Problem 3 *)
(* Goal:
 *   for all n2 in nat,
 *     for all n1 in nat, toInt (multNat n1 n2) = (toInt n1) * (toInt n2)
 *
 * Base: P(Zero) holds true
 *     for all n2 in nat,
 *       (toInt (multNat Zero n2)) evaluates to (toInt Zero) which in turn evaluates to 0
 *   Also, (toInt Zero) * (toInt n2) = 0 * (toInt n2) = 0
 *
 * Inductive steps:
 *  Assume that P(n) holds true which means:
 *    for all n2 in nat,
 *      for all n1 in nat, toInt (multNat n1 n2) = (toInt n1) * (toInt n2)
 *  Show that P(Succ n) holds true which means:
 *    for all n2 in nat,
 *      for all n1 in nat, toInt (multNat (Succ n1) n2) = (toInt (Succ n1)) * (toInt n2)
 *    toInt (multNat (Succ n1) n2)
 *  = toInt (plusNat n2 (multNat n1 n2))
 *  = (toInt n2) + (toInt (multNat n1 n2)) by the correctness of plusNat
 *  = (toInt n2) + ((toInt n1) * (toInt n2)) by the assumption of P(n)
 *  = (1 + (toInt n1)) * (toInt n2) by factoring out (toInt n2)
 *  = (toInt (Succ n1)) * (toInt n2)
 *  => P(Succ n) holds true
